<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BLAZING RUNNER | Ultimate Settings</title>
    
    <meta name="author" content="Jamiul Hasan">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght[400;700]&display=swap" rel="stylesheet"> 
    
    <style>
        body { 
            display: flex; justify-content: center; align-items: center; 
            height: 100vh; margin: 0; 
            background-color: #0f0a1c; 
            font-family: 'Orbitron', sans-serif; 
            user-select: none; touch-action: manipulation;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            border: 8px solid #00FFFF; 
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.9); 
            overflow: hidden; 
            touch-action: manipulation;
        }
        canvas { display: block; }

        /* UI Overlay */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background-color: rgba(0, 0, 0, 0.98);
            color: white; display: flex; flex-direction: column; justify-content: center; 
            align-items: center; text-align: center; z-index: 10;
            opacity: 0; transition: opacity 0.5s ease-in-out; pointer-events: none; 
        }
        .overlay.active { opacity: 1; pointer-events: auto; }
        h1 { font-size: 4.5em; color: #FF00FF; margin-bottom: 5px; text-shadow: 0 0 10px #FF00FF; } 
        h2 { font-size: 1.8em; color: #00FFFF; margin-top: 5px; text-shadow: 0 0 5px #00FFFF; }
        p.control-hint { font-size: 1.1em; color: #888; margin-top: 15px;}
        p.developer-credit { font-size: 0.9em; color: #444; margin-top: 20px;}

        /* ‡¶¨‡¶æ‡¶ü‡¶® ‡¶°‡¶ø‡¶ú‡¶æ‡¶á‡¶® */
        button {
            padding: 15px 35px; margin-top: 20px; font-size: 1.4em; cursor: pointer;
            background-color: #FF00FF; border: 2px solid #00FFFF;
            color: #0f0a1c; 
            border-radius: 5px;
            box-shadow: 0 0 15px #FF00FF, inset 0 0 5px #00FFFF;
            transition: all 0.15s;
        }
        button:hover { background-color: #00FFFF; box-shadow: 0 0 20px #00FFFF, inset 0 0 5px #FF00FF; }
        button:active { transform: scale(0.95); }

        /* Settings Grid */
        #settings-menu {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        .setting-button {
            padding: 10px;
            font-size: 1.1em;
            background-color: #333;
            color: white;
            border: 1px solid #00FFFF;
        }
        .setting-button.selected {
            background-color: #00FFFF;
            color: #0f0a1c;
            box-shadow: 0 0 10px #00FFFF;
        }

        /* ‡¶∏‡ßç‡¶ï‡ßã‡¶∞ ‡¶°‡¶ø‡¶∏‡¶™‡ßç‡¶≤‡ßá */
        #score-display {
            position: absolute; top: 15px; left: 15px; color: #00FFFF; 
            font-size: 1.8em; padding: 8px 18px; background: rgba(0, 0, 0, 0.8);
            border-radius: 5px; letter-spacing: 3px; font-weight: bold;
            text-shadow: 0 0 8px #00FFFF;
            border: 1px solid #00FFFF;
        }
        #mobile-jump-icon {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 80px;
            height: 80px;
            background-color: rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3em;
            color: white;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #touch-area { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; cursor: pointer; }
        
        /* High Score Display */
        #high-score-display {
            position: absolute; top: 15px; right: 15px; color: #FFD700; 
            font-size: 1.2em; padding: 8px 18px; background: rgba(0, 0, 0, 0.8);
            border-radius: 5px; letter-spacing: 2px; font-weight: bold;
            text-shadow: 0 0 8px #FFD700;
            border: 1px solid #FFD700;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="900" height="350"></canvas>
        
        <div id="score-display">SCORE: 000000</div>
        <div id="high-score-display">HIGH: 000000</div>
        <div id="touch-area"></div>
        <div id="mobile-jump-icon">üëÜ</div>
        
        <div id="start-screen" class="overlay active">
            <h1>BLAZING RUNNER</h1>
            <h2>ULTRA-FAST ARCADE ACTION</h2>
            
            <div id="settings-menu">
                <button class="setting-button" data-setting="speed" data-value="easy" id="diff-easy">EASY</button>
                <button class="setting-button selected" data-setting="speed" data-value="normal" id="diff-normal">NORMAL</button>
                <button class="setting-button" data-setting="speed" data-value="hard" id="diff-hard">HARD</button>
                <button class="setting-button selected" data-setting="control" data-value="visible" id="ctrl-visible">CONTROL VISIBLE</button>
                <button class="setting-button" data-setting="control" data-value="hidden" id="ctrl-hidden">CONTROL HIDDEN</button>
            </div>
            
            <button id="startButton">START RUN</button>
            <p class="control-hint">Tap anywhere or press SPACE to jump.</p>
            <p class="developer-credit">Developed by: Jamiul Hasan | <a href="https://facebook.com/jamiul2168" target="_blank" style="color:#00FFFF;">jamiul2168</a></p>
        </div>
        
        <div id="game-over-screen" class="overlay">
            <h1>GAME OVER</h1>
            <h2 id="final-score">Final Score: 0</h2>
            <button id="retryButton">RETRY (R)</button>
            <p class="developer-credit">Developed by: Jamiul Hasan</p>
        </div>
    </div>

    <script>
        window.addEventListener('load', function() {
            // --- 1. GAMESTATE & CONFIGS ---
            const GameState = { READY: 'READY', RUNNING: 'RUNNING', OVER: 'OVER' };
            let gameState = GameState.READY;

            // DOM ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡ßã ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶‡ßá ‡¶∏‡¶Ç‡¶ú‡ßç‡¶û‡¶æ‡¶Ø‡¶º‡¶ø‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreDisplay = document.getElementById('score-display');
            const highScoreDisplay = document.getElementById('high-score-display');
            const gameOverScreen = document.getElementById('game-over-screen');
            const startScreen = document.getElementById('start-screen');
            const touchArea = document.getElementById('touch-area');
            const startButton = document.getElementById('startButton');
            const retryButton = document.getElementById('retryButton');
            const mobileJumpIcon = document.getElementById('mobile-jump-icon');

            const GROUND_Y = canvas.height - 40;
            
            // DIFFICULTY SETTINGS (IMPROVED)
            const BASE_SPEED = 300;
            const BASE_GRAVITY = 1800;
            const BASE_JUMP = -550;

            const SETTINGS = {
                'easy': { speed: BASE_SPEED * 0.8, gravity: BASE_GRAVITY * 0.8, jump: BASE_JUMP * 0.9 },
                'normal': { speed: BASE_SPEED, gravity: BASE_GRAVITY, jump: BASE_JUMP },
                'hard': { speed: BASE_SPEED * 1.2, gravity: BASE_GRAVITY * 1.1, jump: BASE_JUMP * 1.1 },
                'selected_speed': 'normal',
                'controls_visible': true 
            };
            
            // --- CORE CONSTANTS ---
            const MAX_SPEED = 700; 
            const FPS_MULTIPLIER = 1000; 
            const AI_SUCCESS_THRESHOLD = 5; 
            const AI_GRAVITY_MODIFIER = 200; 
            const DIFFICULTY_INCREMENT = 3; 
            const BOOST_SCORE_INTERVAL = 500;
            const SPEED_BOOST_AMOUNT = 100; 
            const GROUND_TILE_WIDTH = 50; 
            const OBSTACLE_SPAWN_MIN_GAP = 80;
            const OBSTACLE_SPAWN_MAX_GAP = 200;

            // --- 2. GLOBAL VARIABLES ---
            let GAME_SPEED = SETTINGS.normal.speed;
            let score = 0;
            let highScore = 0;
            let lastBoostScore = 0;
            let frameCount = 0;
            let groundX = 0;
            let mountainX = 0;
            let animationFrameId;
            let lastTime = 0;
            let deltaTime = 0; 
            let jumpFlashTimer = 0; 
            let lastObstacleHeight = 0;
            let lastObstacleSpawnedTime = 0;
            let obstacleSpawnTimer = 0;

            // --- 3. SOUND MANAGER (IMPROVED) ---
            let audioContext;
            let audioInitialized = false;

            class SoundManager {
                constructor() {
                    this.sounds = {};
                    this.audioContext = null;
                    this.init();
                }
                
                async init() {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        audioContext = this.audioContext;
                        audioInitialized = true;
                        
                        // Create simple tones for sounds
                        this.sounds.jump = this.createTone(523.25, 0.1); // C5
                        this.sounds.gameOver = this.createTone(220, 0.5); // A3
                        this.sounds.boost = this.createTone(659.25, 0.2); // E5
                    } catch (e) {
                        console.warn('Web Audio API not supported. Game will run without sound.');
                    }
                }
                
                createTone(frequency, duration) {
                    return () => {
                        if (!this.audioContext) return;
                        
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.value = frequency;
                        oscillator.type = 'sine';
                        
                        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                        
                        oscillator.start(this.audioContext.currentTime);
                        oscillator.stop(this.audioContext.currentTime + duration);
                    };
                }

                play(soundName) {
                    if (this.sounds[soundName]) {
                        this.sounds[soundName]();
                    }
                }

                playJump() { this.play('jump'); }
                playGameOver() { this.play('gameOver'); }
                playBoost() { this.play('boost'); }
            }
            
            // --- 4. ENTITIES (Improved) ---

            class Mountains {
                constructor(canvas, GROUND_Y) {
                    this.ctx = canvas.getContext('2d');
                    this.width = canvas.width;
                    this.GROUND_Y = GROUND_Y;
                    this.mountainX = 0;
                }
                
                draw(GAME_SPEED) {
                    const speedFactor = 0.2; 
                    const FIXED_MOVEMENT = (GAME_SPEED / 1000) * (1000/60); 

                    this.mountainX = (this.mountainX - FIXED_MOVEMENT * speedFactor) % this.width;

                    this.ctx.fillStyle = '#1e1e3f'; 

                    for (let i = 0; i < 2; i++) {
                        const xOffset = this.mountainX + i * this.width;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(xOffset - 100, this.GROUND_Y);
                        this.ctx.lineTo(xOffset + 250, this.GROUND_Y - 120);
                        this.ctx.lineTo(xOffset + 500, this.GROUND_Y - 70);
                        this.ctx.lineTo(xOffset + 850, this.GROUND_Y - 180);
                        this.ctx.lineTo(xOffset + 1000, this.GROUND_Y);
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                }
            }

            class Player {
                constructor(canvas, GROUND_Y, soundManager) {
                    this.ctx = canvas.getContext('2d');
                    this.soundManager = soundManager;
                    this.GROUND_Y = GROUND_Y;

                    this.initialY = GROUND_Y - 50;
                    this.x = 50; 
                    this.y = this.initialY; 
                    this.width = 30; 
                    this.height = 50;
                    this.velocityY = 0; 
                    this.isJumping = false;
                    this.hitboxOffset = {x: 5, y: 5, width: -10, height: -5}; 
                    this.successfulJumps = 0; 
                    
                    // Settings will be applied on reset
                    this.gravity = 0;
                    this.MAX_JUMP_VELOCITY = 0;
                }

                reset() {
                    this.y = this.initialY;
                    this.velocityY = 0;
                    this.isJumping = false;
                    this.successfulJumps = 0; 
                    
                    // Apply current settings
                    const currentSettings = SETTINGS[SETTINGS.selected_speed];
                    this.gravity = currentSettings.gravity;
                    this.MAX_JUMP_VELOCITY = currentSettings.jump;
                }

                draw(frameCount, gameState) {
                    // Player body with glow effect
                    this.ctx.shadowColor = '#FF00FF'; 
                    this.ctx.shadowBlur = 10;
                    this.ctx.fillStyle = '#FF00FF'; 
                    this.ctx.fillRect(this.x, this.y, this.width, this.height);
                    this.ctx.shadowBlur = 0; 

                    // Running animation (legs)
                    if (gameState === GameState.RUNNING && !this.isJumping) {
                        this.ctx.fillStyle = (frameCount % 8 < 4) ? '#00FFFF' : '#00AABB'; 
                        this.ctx.fillRect(this.x + 5, this.y + this.height - 10, 5, 10); 
                        this.ctx.fillRect(this.x + 20, this.y + this.height - 10, 5, 10);
                    }
                    
                    // Jump effect
                    if (this.isJumping && this.velocityY < 0) {
                        this.ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                        this.ctx.fillRect(this.x - 10, this.y + this.height, 50, 10);
                    }
                }
                
                update(dt) {
                    this.velocityY += this.gravity * dt;
                    this.y += this.velocityY * dt;

                    if (this.y + this.height > this.GROUND_Y) {
                        this.y = this.GROUND_Y - this.height;
                        this.velocityY = 0;
                        this.isJumping = false;
                    }
                }
                
                jump() {
                    if (!this.isJumping) {
                        this.isJumping = true;
                        this.velocityY = this.MAX_JUMP_VELOCITY; 
                        this.soundManager.playJump();
                    }
                }
                
                getHitbox() {
                    return {
                        x: this.x + this.hitboxOffset.x,
                        y: this.y + this.hitboxOffset.y,
                        width: this.width + this.hitboxOffset.width,
                        height: this.height + this.hitboxOffset.height
                    };
                }
            }

            class Obstacle {
                constructor(canvas, GROUND_Y, customHeight) {
                    this.ctx = canvas.getContext('2d');
                    this.width = Math.random() * 20 + 20;
                    this.height = customHeight || (Math.random() * 30 + 30);
                    this.y = GROUND_Y - this.height;
                    this.x = canvas.width;
                    this.color = '#FF00FF'; 
                    this.passed = false; 
                }
                
                draw() {
                    this.ctx.shadowColor = '#FF00FF';
                    this.ctx.shadowBlur = 10;
                    this.ctx.fillStyle = this.color;
                    this.ctx.fillRect(this.x, this.y, this.width, this.height);
                    this.ctx.shadowBlur = 0;
                }
                
                update(GAME_SPEED) {
                    const FIXED_MOVEMENT = (GAME_SPEED / 1000) * (1000/60); 
                    this.x -= FIXED_MOVEMENT;
                }
            }

            // --- 5. GAME LOGIC CORE ---
            
            // ‡¶ó‡ßç‡¶≤‡ßã‡¶¨‡¶æ‡¶≤ ‡¶á‡¶®‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶∏
            let soundManager;
            let mountains;
            let player;
            let obstacles = [];

            function initializeGameObjects() {
                soundManager = new SoundManager();
                mountains = new Mountains(canvas, GROUND_Y); 
                player = new Player(canvas, GROUND_Y, soundManager);
                obstacles = []; 
                GAME_SPEED = SETTINGS[SETTINGS.selected_speed].speed;
                
                // Reset player with current settings
                player.reset();
            }

            function drawGround() {
                const FIXED_MOVEMENT = (GAME_SPEED / 1000) * (1000/60); 
                groundX = (groundX - FIXED_MOVEMENT) % GROUND_TILE_WIDTH;
                
                ctx.fillStyle = '#0f0a1c'; 
                ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);
                
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 5;
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 2;
                for (let x = groundX; x < canvas.width; x += GROUND_TILE_WIDTH / 2) {
                    ctx.beginPath();
                    ctx.moveTo(x, GROUND_Y);
                    ctx.lineTo(x, GROUND_Y + 10);
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, GROUND_Y);
                ctx.lineTo(canvas.width, GROUND_Y);
                ctx.stroke();
            }

            function dynamicDifficulty() {
                // Gradually increase game speed
                if (GAME_SPEED < MAX_SPEED) {
                    GAME_SPEED += (DIFFICULTY_INCREMENT / FPS_MULTIPLIER) * deltaTime;
                }

                // Speed boost at score intervals
                if (score > lastBoostScore + BOOST_SCORE_INTERVAL) {
                    if (GAME_SPEED + SPEED_BOOST_AMOUNT < MAX_SPEED) {
                         GAME_SPEED += SPEED_BOOST_AMOUNT;
                         soundManager.playBoost();
                    } else {
                        GAME_SPEED = MAX_SPEED;
                    }
                    lastBoostScore = score;
                }

                // AI difficulty adjustment based on player performance
                if (player && player.successfulJumps >= AI_SUCCESS_THRESHOLD) {
                    if (player.gravity < BASE_GRAVITY + AI_GRAVITY_MODIFIER * 3) {
                        player.gravity += AI_GRAVITY_MODIFIER; 
                        player.MAX_JUMP_VELOCITY -= 50; 
                        player.successfulJumps = 0;
                    }
                }

                // Adjust obstacle spawn gap based on game speed
                const gapFactor = 1 - (GAME_SPEED / MAX_SPEED) * 0.7;
                const currentGap = OBSTACLE_SPAWN_MIN_GAP + (OBSTACLE_SPAWN_MAX_GAP - OBSTACLE_SPAWN_MIN_GAP) * gapFactor;
                return currentGap;
            }

            function generateObstacles() {
                const spawnGap = dynamicDifficulty();

                if (obstacleSpawnTimer <= 0) {
                    let randomHeight = Math.random() * 30 + 30; 
                    const currentTime = performance.now();
                    
                    // Prevent spawning obstacles too close together when player is jumping
                    if (player && player.isJumping && player.velocityY < 0 && currentTime - lastObstacleSpawnedTime < 500) {
                         obstacleSpawnTimer = 200; 
                         return; 
                    }

                    // Occasionally spawn lower obstacles after high ones
                    if (lastObstacleHeight > 50 && Math.random() < 0.6) {
                        randomHeight = Math.random() * 15 + 20; 
                    }

                    const newObstacle = new Obstacle(canvas, GROUND_Y, randomHeight);
                    obstacles.push(newObstacle);

                    lastObstacleHeight = newObstacle.height;
                    lastObstacleSpawnedTime = currentTime;
                    obstacleSpawnTimer = spawnGap + Math.random() * 50;

                } else {
                    obstacleSpawnTimer -= deltaTime; 
                }
            }

            function trackPlayerSuccess() {
                if (!player) return;
                const playerBaseY = player.GROUND_Y - player.height;
                
                // Check if player successfully jumped over an obstacle
                if (player.y < playerBaseY && player.velocityY > 0) {
                    const nearestObstacle = obstacles[0];
                    
                    if (nearestObstacle && nearestObstacle.x + nearestObstacle.width < player.x) {
                        if (!nearestObstacle.passed) { 
                            player.successfulJumps++; 
                            nearestObstacle.passed = true;
                        }
                    }
                }
            }

            function checkCollision() {
                 if (!player) return false;
                const playerHitbox = player.getHitbox();
                for (let i = 0; i < obstacles.length; i++) {
                    let obs = obstacles[i];
                    
                    if (
                        playerHitbox.x < obs.x + obs.width &&
                        playerHitbox.x + playerHitbox.width > obs.x &&
                        playerHitbox.y < obs.y + obs.height &&
                        playerHitbox.y + playerHitbox.height > obs.y
                    ) {
                        endGame();
                        return true;
                    }
                }
                return false;
            }

            function resetGame() {
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('runnerHighScore', highScore);
                    updateHighScoreDisplay();
                }
                score = 0;
                GAME_SPEED = SETTINGS[SETTINGS.selected_speed].speed;
                lastBoostScore = 0;
                obstacles = [];
                obstacleSpawnTimer = 0;
                if (player) player.reset();
                frameCount = 0;
                highScore = localStorage.getItem('runnerHighScore') || 0;
            }

            function updateHighScoreDisplay() {
                highScoreDisplay.textContent = `HIGH: ${highScore.toString().padStart(6, '0')}`;
            }

            function startGame() {
                if (gameState === GameState.RUNNING) return;
                
                // Initialize game objects if not already done
                if (!player) {
                    initializeGameObjects();
                }
                
                // Resume audio context if needed
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                gameState = GameState.RUNNING;
                startScreen.classList.remove('active');
                gameOverScreen.classList.remove('active');
                
                resetGame();
                lastTime = performance.now(); 
                gameLoop(lastTime);
            }

            function endGame() {
                if (gameState === GameState.OVER) return;
                gameState = GameState.OVER;
                cancelAnimationFrame(animationFrameId);
                
                document.getElementById('final-score').innerHTML = 
                    `Final Score: <span style="color:#FF00FF">${score.toString().padStart(6, '0')}</span><br>
                     High Score: ${highScore.toString().padStart(6, '0')}`;
                gameOverScreen.classList.add('active');
                soundManager.playGameOver();
            }

            function gameLoop(currentTime) {
                deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                const dt = deltaTime / FPS_MULTIPLIER; 

                if (gameState !== GameState.RUNNING) {
                    if (jumpFlashTimer > 0) jumpFlashTimer -= dt;
                    return;
                }

                // A. Update game state
                player.update(dt); 
                generateObstacles();
                obstacles.forEach(obs => obs.update(GAME_SPEED));
                obstacles = obstacles.filter(obs => obs.x + obs.width > 0);
                checkCollision();
                trackPlayerSuccess();

                // B. Render everything
                ctx.fillStyle = '#0f0a1c'; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                mountains.draw(GAME_SPEED);
                drawGround();
                player.draw(frameCount, gameState);
                obstacles.forEach(obs => obs.draw());

                // C. Visual effects
                if (jumpFlashTimer > 0) {
                    ctx.fillStyle = `rgba(0, 255, 255, ${jumpFlashTimer * 0.5})`; 
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    jumpFlashTimer -= dt * 2; 
                }

                // D. Scoring
                frameCount++;
                score += Math.floor(GAME_SPEED * dt); 
                
                let scoreText = score.toString().padStart(6, '0');
                if (score > highScore && score > 0) {
                    scoreText = `<span style="color:#FFD700; text-shadow: 0 0 5px #FFD700;">${scoreText}</span>`;
                }
                scoreDisplay.innerHTML = 'SCORE: ' + scoreText;

                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // --- 6. INPUT HANDLING & SETTINGS ---
            function handleJumpInput(event) {
                if (event && event.type === 'touchstart') { 
                    event.preventDefault(); 
                }
                
                if (gameState === GameState.READY) {
                    startGame();
                } else if (gameState === GameState.RUNNING) {
                    if(player) player.jump();
                    jumpFlashTimer = 1; 
                }
            }
            
            function updateControlVisibility() {
                mobileJumpIcon.style.opacity = SETTINGS.controls_visible ? 1 : 0;
            }

            // ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç ‡¶¨‡¶æ‡¶ü‡¶® ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡ßá‡¶≤ ‡¶ï‡¶∞‡¶æ
            document.querySelectorAll('.setting-button').forEach(button => {
                button.addEventListener('click', function() {
                    const settingType = this.dataset.setting;
                    const value = this.dataset.value;
                    
                    // ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü (‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü‡ßá‡¶° ‡¶è‡¶´‡ßá‡¶ï‡ßç‡¶ü)
                    document.querySelectorAll(`[data-setting="${settingType}"]`).forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    this.classList.add('selected');

                    if (settingType === 'speed') {
                        SETTINGS.selected_speed = value;
                        // Update game speed if running
                        if (gameState === GameState.RUNNING) {
                            GAME_SPEED = SETTINGS[value].speed;
                            if (player) player.reset();
                        }
                    } else if (settingType === 'control') {
                        SETTINGS.controls_visible = (value === 'visible');
                        updateControlVisibility();
                    }
                });
            });

            // ‡¶á‡¶≠‡ßá‡¶®‡ßç‡¶ü ‡¶≤‡¶ø‡¶∏‡ßá‡¶®‡¶æ‡¶∞ ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™
            document.addEventListener('keydown', (event) => {
                if (event.code === 'Space' || event.code === 'ArrowUp') {
                    handleJumpInput(event);
                }
                if (gameState === GameState.OVER && (event.code === 'Enter' || event.code === 'KeyR')) {
                    startGame();
                }
            });

            touchArea.addEventListener('mousedown', handleJumpInput); 
            touchArea.addEventListener('touchstart', handleJumpInput); 
            startButton.addEventListener('click', handleJumpInput); 
            retryButton.addEventListener('click', startGame);

            // ‡¶π‡¶æ‡¶á ‡¶∏‡ßç‡¶ï‡ßã‡¶∞ ‡¶≤‡ßã‡¶° ‡¶ì ‡¶°‡¶ø‡¶∏‡¶™‡ßç‡¶≤‡ßá
            highScore = localStorage.getItem('runnerHighScore') || 0;
            updateHighScoreDisplay();
            
            // ‡¶™‡ßç‡¶∞‡¶æ‡¶•‡¶Æ‡¶ø‡¶ï ‡¶≠‡¶ø‡¶ú‡¶ø‡¶¨‡¶ø‡¶≤‡¶ø‡¶ü‡¶ø ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ
            updateControlVisibility(); 
        });
    </script>
</body>
</html>
